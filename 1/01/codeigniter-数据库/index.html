<!DOCTYPE html>
<html lang="zh">
  <head>
    <title>
         - my101du Blog
      </title>
        <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
    <meta name="renderer" content="webkit">
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    
    <meta name="theme-color" content="#000000" />
    
    <meta http-equiv="window-target" content="_top" />
    
    
    <meta name="description" content="快速开始 初始化数据库类 (根据数据库配置信息来初始化) 如果你所有的页面都需要连接数据库，你可以让其自动加载 $this-&amp;gt;load-&amp;gt;database(); 多结果标准查询(多种形式) /** * 对象" />
    <meta name="generator" content="Hugo 0.70.0 with theme pure" />
    <title> - my101du Blog</title>
    
    
    <link rel="stylesheet" href="https://my101du.github.io/css/style.min.7dc20efbc53647d41aa9ddea0c48e59300223d084e66ea0cbe7c30bd88903acc.css">
    
    <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/9.15.10/styles/github.min.css" async>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css" async>
    <meta property="og:title" content="" />
<meta property="og:description" content="快速开始 初始化数据库类 (根据数据库配置信息来初始化) 如果你所有的页面都需要连接数据库，你可以让其自动加载 $this-&gt;load-&gt;database(); 多结果标准查询(多种形式) /** * 对象" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://my101du.github.io/1/01/codeigniter-%E6%95%B0%E6%8D%AE%E5%BA%93/" />

<meta itemprop="name" content="">
<meta itemprop="description" content="快速开始 初始化数据库类 (根据数据库配置信息来初始化) 如果你所有的页面都需要连接数据库，你可以让其自动加载 $this-&gt;load-&gt;database(); 多结果标准查询(多种形式) /** * 对象">

<meta itemprop="wordCount" content="11594">



<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="快速开始 初始化数据库类 (根据数据库配置信息来初始化) 如果你所有的页面都需要连接数据库，你可以让其自动加载 $this-&gt;load-&gt;database(); 多结果标准查询(多种形式) /** * 对象"/>

    <!--[if lte IE 9]>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
      <![endif]-->

    <!--[if lt IE 9]>
        <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
      <![endif]-->
  </head>

  
  

  <body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader">
    <div class="slimContent">
      <div class="navbar-header">
        <div class="profile-block text-center">
          <a id="avatar" href="https://github.com/my101du" target="_blank">
            <img class="img-circle img-rotate" src="https://avatars2.githubusercontent.com/u/1332645?s=460&amp;u=dc114d6baad010456a5af87c4cc2df0694ff2b1c&amp;v=4" width="200" height="200">
          </a>
          <h2 id="name" class="hidden-xs hidden-sm">my101du</h2>
          <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
          <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i>Dongguan, China</small>
        </div><div class="search" id="search-form-wrap">
    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i
                        class="icon icon-search"></i></button>
            </span>
        </div>
        <div class="ins-search">
            <div class="ins-search-mask"></div>
            <div class="ins-search-container">
                <div class="ins-input-wrapper">
                    <input type="text" class="ins-search-input" placeholder="想要查找什么..."
                        x-webkit-speech />
                    <button type="button" class="close ins-close ins-selectable" data-dismiss="modal"
                        aria-label="Close"><span aria-hidden="true">×</span></button>
                </div>
                <div class="ins-section-wrapper">
                    <div class="ins-section-container"></div>
                </div>
            </div>
        </div>
    </form>
</div>
        <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
      </div>
      <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
        <ul class="nav navbar-nav main-nav">
            <li class="menu-item menu-item-home">
                <a href="/">
                    <i class="icon icon-home-fill"></i>
                  <span class="menu-title">Home</span>
                </a>
            </li>
            <li class="menu-item menu-item-archives">
                <a href="/posts/">
                    <i class="icon icon-archives-fill"></i>
                  <span class="menu-title">Archives</span>
                </a>
            </li>
            <li class="menu-item menu-item-categories">
                <a href="/categories/">
                    <i class="icon icon-folder"></i>
                  <span class="menu-title">Categories</span>
                </a>
            </li>
            <li class="menu-item menu-item-tags">
                <a href="/tags/">
                    <i class="icon icon-tags"></i>
                  <span class="menu-title">Tags</span>
                </a>
            </li>
            <li class="menu-item menu-item-about">
                <a href="/about/">
                    <i class="icon icon-cup-fill"></i>
                  <span class="menu-title">About</span>
                </a>
            </li>
        </ul>
      </nav>
    </div>
  </header>

<aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content"><p>enjoy~</p>
            </div>
        </div>
    </div>
</div>

      <div class="widget">
    <h3 class="widget-title"> 分类</h3>
    <div class="widget-body">
        <ul class="category-list">
        </ul>
    </div>
</div>
      <div class="widget">
    <h3 class="widget-title"> 标签</h3>
    <div class="widget-body">
        <ul class="tag-list">
            
        </ul>

    </div>
</div>
      
<div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
        <ul class="recent-post-list list-unstyled no-thumbnail">
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://my101du.github.io/1/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" class="title"></a>
                    </p>
                    <p class="item-date">
                        <time datetime="0001-01-01 00:00:00 &#43;0000 UTC" itemprop="datePublished">0001-01-01</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://my101du.github.io/1/01/bootstrap-%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E4%B8%8E%E6%8A%80%E5%B7%A7/" class="title"></a>
                    </p>
                    <p class="item-date">
                        <time datetime="0001-01-01 00:00:00 &#43;0000 UTC" itemprop="datePublished">0001-01-01</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://my101du.github.io/1/01/bootstrap4/" class="title"></a>
                    </p>
                    <p class="item-date">
                        <time datetime="0001-01-01 00:00:00 &#43;0000 UTC" itemprop="datePublished">0001-01-01</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://my101du.github.io/1/01/css-%E5%8A%A8%E7%94%BB/" class="title"></a>
                    </p>
                    <p class="item-date">
                        <time datetime="0001-01-01 00:00:00 &#43;0000 UTC" itemprop="datePublished">0001-01-01</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://my101du.github.io/1/01/css-%E5%8A%A8%E7%94%BB%E5%BA%93-animate.css/" class="title"></a>
                    </p>
                    <p class="item-date">
                        <time datetime="0001-01-01 00:00:00 &#43;0000 UTC" itemprop="datePublished">0001-01-01</time>
                    </p>
                </div>
            </li>
        </ul>
    </div>
</div>
  </div>
</aside>

    
    
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <h4 class="toc-title">文章目录</h4>
    <nav id="toc" class="js-toc toc">

    </nav>
  </div>
</aside>
<main class="main" role="main"><div class="content">
  <article id="-" class="article article-type-" itemscope
    itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      <h1 itemprop="name">
  <a
    class="article-title"
    href="/1/01/codeigniter-%E6%95%B0%E6%8D%AE%E5%BA%93/"
    ></a
  >
</h1>

      <div class="article-meta">
        

        <span class="post-comment"><i class="icon icon-comment"></i>&nbsp;<a href="/1/01/codeigniter-%E6%95%B0%E6%8D%AE%E5%BA%93/#comments"
            class="article-comment-link">评论</a></span>
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 11594字</span>
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 24分 </span>
      </div>
    </div>
    <div class="article-entry marked-body js-toc-content" itemprop="articleBody">
      <h1 id="快速开始">快速开始</h1>
<h2 id="初始化数据库类-根据数据库配置信息来初始化">初始化数据库类 (根据数据库配置信息来初始化)</h2>
<p>如果你所有的页面都需要连接数据库，你可以让其自动加载</p>
<pre><code class="language-php">$this-&gt;load-&gt;database();
</code></pre>
<h2 id="多结果标准查询多种形式">多结果标准查询(多种形式)</h2>
<pre><code class="language-php">/**
 * 对象形式
 */
$query = $this-&gt;db-&gt;query('SELECT name, title, email FROM my_table');

//result() 函数返回一个**对象数组**。例如：$row-&gt;title
foreach ($query-&gt;result() as $row)
{
    echo $row-&gt;title;
    echo $row-&gt;name;
    echo $row-&gt;email;
}

echo 'Total Results: ' . $query-&gt;num_rows();


/**
 * 数组形式
 */
$query = $this-&gt;db-&gt;query('SELECT name, title, email FROM my_table');

//result_array() 函数返回一个**数组的数组**。例如：$row['title']
foreach ($query-&gt;result_array() as $row)
{
    echo $row['title'];
    echo $row['name'];
    echo $row['email'];
}
</code></pre>
<h2 id="单结果标准查询">单结果标准查询</h2>
<pre><code class="language-php">/**
 * 对象形式
 */
$query = $this-&gt;db-&gt;query('SELECT name FROM my_table LIMIT 1');
// row() 函数返回一个**对象**。例如：$row-&gt;name
$row = $query-&gt;row();
echo $row-&gt;name;

/**
 * 数组形式
 */
$query = $this-&gt;db-&gt;query('SELECT name FROM my_table LIMIT 1');
//row_array() 函数返回一个**数组**。例如：$row['name']
$row = $query-&gt;row_array();
echo $row['name'];
</code></pre>
<h2 id="标准插入数据">标准插入数据</h2>
<pre><code class="language-php">$sql = &quot;INSERT INTO mytable (title, name) VALUES (&quot;.$this-&gt;db-&gt;escape($title).&quot;, &quot;.$this-&gt;db-&gt;escape($name).&quot;)&quot;;
$this-&gt;db-&gt;query($sql);
echo $this-&gt;db-&gt;affected_rows();
</code></pre>
<h2 id="使用-查询构造器-查询数据--插入数据">使用 查询构造器 查询数据 &amp; 插入数据</h2>
<p>文档：/database/query_builder.html</p>
<p>查询构造器 提供了所有数据库操作的<strong>快捷函数</strong>。</p>
<pre><code class="language-php">//get() 函数从给定的表中查询出所有的结果。
$query = $this-&gt;db-&gt;get('table_name');

foreach ($query-&gt;result() as $row)
{
    echo $row-&gt;title;
}
</code></pre>
<p>使用查询构造器插入数据</p>
<pre><code class="language-php">$data = array(
    'title' =&gt; $title,
    'name' =&gt; $name,
    'date' =&gt; $date
);

//
// 生成这样的SQL代码:
//   INSERT INTO mytable (title, name, date) VALUES ('{$title}', '{$name}', '{$date}')
//
$this-&gt;db-&gt;insert('mytable', $data);
</code></pre>
<h1 id="配置">配置</h1>
<h2 id="配置文件">配置文件</h2>
<p>application/config/database.php</p>
<p>一看便知</p>
<h3 id="dsn-字符串特殊的数据库驱动">DSN 字符串（特殊的数据库驱动）</h3>
<p>有些数据库驱动（例如：PDO，PostgreSQL，Oracle，ODBC）可能需要提供完整的 DSN 字符串。在这种情况下，你需要使用 &lsquo;dsn&rsquo; 配置参数，就好像使用该驱动的 PHP 原生扩展一样</p>
<p>(如果你没有为需要 DSN 参数的驱动指定 DSN 字符串，CodeIgniter 将使用你提供的其他配置信息自动生成它。如果你提供了一个 DSN 字符串，但是缺少了某些配置（例如：数据库的字符集），如果该配置存在在其他的配置项中，CodeIgniter 将自动在 DSN 上附加上该配置。)</p>
<pre><code class="language-php">// PDO
$db['default']['dsn'] = 'pgsql:host=localhost;port=5432;dbname=database_name';

// Oracle
$db['default']['dsn'] = '//localhost/XE';
</code></pre>
<h3 id="存储多个连接在不同环境之间切换active_group-指定当前配置">存储多个连接，在不同环境之间切换(active_group 指定当前配置)</h3>
<p>我们使用多维数组的原因是为了让你随意的存储多个连接值的设置，例如：如果你有多个环境（开发、生产、测试 等等），你能为每个环境建立独立的连接组，并在组之间进行切换</p>
<p>默认情况下，主连接使用“default”这个名称</p>
<p>首先设置一个“test”环境</p>
<pre><code class="language-php">$db['test'] = array(
    'dsn'   =&gt; '',
    'hostname' =&gt; 'localhost',
    'username' =&gt; 'root',
    'password' =&gt; '',
    'database' =&gt; 'database_name',
    'dbdriver' =&gt; 'mysqli',
    'dbprefix' =&gt; '',
    'pconnect' =&gt; TRUE,
    //....
);
</code></pre>
<p>然后，设置位于配置文件中的 <code>$active_group</code> 变量，告诉系统要使用“test”组:</p>
<pre><code class="language-php">$active_group = 'test';

</code></pre>
<h2 id="故障转移无法连接">故障转移（无法连接）</h2>
<p>当主数据库由于某些原因无法连接时，你还可以配置故障转移（failover）,你可以指定任意多个故障转移。</p>
<pre><code class="language-php">$db['default']['failover'] = array(
        array(
            'hostname' =&gt; 'localhost1',
            'username' =&gt; '',
            'password' =&gt; '',
            //...
            'stricton' =&gt; FALSE
        ),
        array(
            'hostname' =&gt; 'localhost2',
            'username' =&gt; '',
            'password' =&gt; '',
          //....
            'compress' =&gt; FALSE,
            'stricton' =&gt; FALSE
        )
    );
</code></pre>
<h2 id="查询构造器-开关建议一直开启">查询构造器 开关(建议一直开启)</h2>
<p><code>$query_builder</code> 变量对 <strong>查询构造器类</strong> 进行全局的设定（启用设成 TRUE，禁用设成 FALSE，默认是 TRUE）。如果你不用这个类，那么你可以通过将这个变量值设置成 FALSE 来减少在数据库类初始化时对电脑资源的消耗。</p>
<p>一些 CodeIgniter 的类，例如 Sessions，在执行一些函数的时候需要查询构造器的支持。</p>
<pre><code class="language-php">$query_builder = TRUE;

</code></pre>
<h2 id="完整的参数解释-略">完整的参数解释 （略）</h2>
<h1 id="连接数据库">连接数据库</h1>
<h2 id="自动连接">自动连接</h2>
<p>在 application/config/autoload.php 中的 library 数组里添加 database <code>$autoload['libraries'] = array('database');</code></p>
<h2 id="手动连接">手动连接</h2>
<p>可用的参数</p>
<ul>
<li>数据库连接值，用数组或DSN字符串传递；</li>
<li>TRUE/FALSE (boolean) - 是否返回连接ID（参考下文的“连接多数据库”）；</li>
<li>TRUE/FALSE (boolean) - 是否启用查询构造器类，默认为 TRUE 。</li>
</ul>
<pre><code class="language-php">$this-&gt;load-&gt;database();

$this-&gt;load-&gt;database('group_name');

</code></pre>
<p>或者在代码里连接一个完全手动指定的数据库，可以传一个数组参数:</p>
<pre><code class="language-php">$config['hostname'] = 'localhost';
$config['username'] = 'myusername';
$config['password'] = 'mypassword';
$config['database'] = 'mydatabase';
//....

$this-&gt;load-&gt;database($config);
</code></pre>
<p>对于PDO 指定DSN, 或者覆盖默认配置</p>
<pre><code class="language-php">$dsn = 'dbdriver://username:password@hostname/database';
$this-&gt;load-&gt;database($dsn);

//覆盖默认配置, 可以像添加查询字符串一样添加配置变量
$dsn = 'dbdriver://username:password@hostname/database?char_set=utf8&amp;dbcollat=utf8_general_ci&amp;cache_on=true&amp;cachedir=/path/to/cache';
$this-&gt;load-&gt;database($dsn);
</code></pre>
<h2 id="同时连接到多个数据库">同时连接到多个数据库</h2>
<p>把返回值分别给不同的变量, <strong>关键是 第二个参数 TRUE 表示函数将返回数据库对象。</strong></p>
<pre><code class="language-php">$DB1 = $this-&gt;load-&gt;database('group_one', TRUE);
$DB2 = $this-&gt;load-&gt;database('group_two', TRUE);
</code></pre>
<p>使用这种方式连接数据库时，你将通过你的对象名来执行数据库命令</p>
<pre><code class="language-php">// 不再是通过 $this-&gt;db 的方式
$this-&gt;db-&gt;query();
$this-&gt;db-&gt;result();

//取而代之的，你将这样执行数据库命令：
$DB1-&gt;query();
$DB1-&gt;result();
</code></pre>
<h2 id="切换到-同一个连接-的另一个-不同的数据库">切换到 同一个连接 的另一个 不同的数据库</h2>
<pre><code class="language-php">$this-&gt;db-&gt;db_select($database2_name);

</code></pre>
<h2 id="重新连接--保持连接有效">重新连接 / 保持连接有效</h2>
<p>在处理一些重量级的 PHP 操作时（例如处理图片），如果超过了数据库的超时值， 你应该考虑在执行后续查询之前先调用 reconnect() 方法向数据库发送 ping 命令， 这样可以优雅的保持连接有效或者重新建立起连接。</p>
<pre><code class="language-php">$this-&gt;db-&gt;reconnect();

</code></pre>
<h2 id="关闭连接">关闭连接</h2>
<p>虽然 CodeIgniter 可以智能的管理并自动关闭数据库连接，你仍可以用下面的方法显式的关闭连接：</p>
<pre><code class="language-php">$this-&gt;db-&gt;close();

</code></pre>
<h1 id="查询查询构造器结果-另文">查询、查询构造器、结果 (另文)</h1>
<h1 id="事务-mysql-特殊-仅-innodb等引擎才支持-myisam-不支持">事务 (MySQL 特殊: 仅 InnoDb等引擎才支持， MyISAM 不支持)</h1>
<p>如果不懂什么叫事务，先在网上寻找一些 在线资源学习一下</p>
<h2 id="codeigniter-的事务方法">CodeIgniter 的事务方法</h2>
<p>CI 实现了一个智能的事务系统, 跟踪你的查询，并根据查询的成功 或失败来决定提交还是回滚(如果愿意，也能手动处理)</p>
<h2 id="运行事务">运行事务</h2>
<p>在 start 和 complete 之间，你可以运行任意多个查询，根据查询执行 成功或失败，系统将自动提交或回滚</p>
<pre><code class="language-php">$this-&gt;db-&gt;trans_start();
$this-&gt;db-&gt;query('AN SQL QUERY...');
$this-&gt;db-&gt;query('ANOTHER QUERY...');
$this-&gt;db-&gt;query('AND YET ANOTHER QUERY...');
$this-&gt;db-&gt;trans_complete();
</code></pre>
<h2 id="严格模式-strict-mode">严格模式 （Strict Mode）</h2>
<p>默认使用严格模式运行所有的事务，在严格模式下，如果你正在 运行多组事务，只要有一组失败，所有组都会被回滚。如果禁用严格模式，那么 每一组都被视为独立的组，这意味着其中一组失败不会影响其他的组</p>
<p>如果要禁用</p>
<pre><code class="language-php">$this-&gt;db-&gt;trans_strict(FALSE);
</code></pre>
<h2 id="错误处理">错误处理</h2>
<p>数据库配置文件 config/database.php 中启用了错误报告（db_debug = TRUE）， 当提交没有成功时，你会看到一条标准的错误信息</p>
<p>如果没有启用错误报告， 你可以像下面这样来管理你的错误:</p>
<pre><code class="language-php">$this-&gt;db-&gt;trans_start();
$this-&gt;db-&gt;query('AN SQL QUERY...');
$this-&gt;db-&gt;query('ANOTHER QUERY...');
$this-&gt;db-&gt;trans_complete();

if ($this-&gt;db-&gt;trans_status() === FALSE)
{
    // generate an error... or use the log_message() function to log your error
}
</code></pre>
<h2 id="禁用事务">禁用事务</h2>
<p>查询会自动提交，就跟没有使用事务一样， trans_start() 和 trans_complete() 等方法调用也将被忽略。</p>
<pre><code class="language-php">$this-&gt;db-&gt;trans_off();

$this-&gt;db-&gt;trans_start();
$this-&gt;db-&gt;query('AN SQL QUERY...');
$this-&gt;db-&gt;trans_complete();

</code></pre>
<h2 id="测试模式test-mode">测试模式（Test Mode）</h2>
<p>将导致你的所有 查询都被回滚，就算查询成功执行也一样</p>
<pre><code class="language-php">$this-&gt;db-&gt;trans_start(TRUE); // Query will be rolled back
$this-&gt;db-&gt;query('AN SQL QUERY...');
$this-&gt;db-&gt;trans_complete();
</code></pre>
<h2 id="手工运行事务">手工运行事务</h2>
<p>注意，方法叫 <code>trans_begin()</code> 而不是 <code>trans_start()</code></p>
<pre><code class="language-php">$this-&gt;db-&gt;trans_begin();

$this-&gt;db-&gt;query('AN SQL QUERY...');
$this-&gt;db-&gt;query('ANOTHER QUERY...');
$this-&gt;db-&gt;query('AND YET ANOTHER QUERY...');

if ($this-&gt;db-&gt;trans_status() === FALSE)
{
    $this-&gt;db-&gt;trans_rollback();
}
else
{
    $this-&gt;db-&gt;trans_commit();
}
</code></pre>
<h1 id="数据库元数据">数据库元数据</h1>
<h2 id="表元数据">表元数据</h2>
<pre><code class="language-php">//列出表
$tables = $this-&gt;db-&gt;list_tables();

//表是否存在
$this-&gt;db-&gt;table_exists();
</code></pre>
<h2 id="字段元数据">字段元数据</h2>
<pre><code class="language-php">//列出字段，将表名称作为参数传入
$fields = $this-&gt;db-&gt;list_fields('table_name');

//列出字段，还可以从任何查询结果对象上调用该方法，获取查询返回的所有字段:
$query = $this-&gt;db-&gt;query('SELECT * FROM some_table');

foreach ($query-&gt;list_fields() as $field) {}


//字段是否存在
$this-&gt;db-&gt;field_exists()


// 字段的元数据(如数据类型，最大长度等等)
$fields = $this-&gt;db-&gt;field_data('table_name');

foreach ($fields as $field)
{
    echo $field-&gt;name;
    echo $field-&gt;type;
    echo $field-&gt;max_length;
    echo $field-&gt;primary_key;
}
//也可以在查询结果对象上调用该方法
$query = $this-&gt;db-&gt;query(&quot;YOUR QUERY&quot;);
$fields = $query-&gt;field_data();
</code></pre>
<h1 id="自定义函数调用">自定义函数调用</h1>
<p>执行一些 CodeIgniter 中没有定义的 PHP 数据库函数，而且 使用了一种平台独立的方式</p>
<p>例如 <code>mysql_get_client_info()</code> 函数，这个函数 CodeIgniter 并不是原生支持的</p>
<p>提供一个 **不带 mysql_ 前缀**的函数名来作为第一个参数</p>
<pre><code class="language-php">// 会根据当前所使用的数据库驱动自动添加前缀, 这样可以在不同的数据库平台 执行相同的函数
$this-&gt;db-&gt;call_function('get_client_info');

// 其他参数
$this-&gt;db-&gt;call_function('some_function', $param1, $param2, etc..);

</code></pre>
<h1 id="获取-connect-id--result-id">获取 connect id &amp; result id</h1>
<pre><code class="language-php">$this-&gt;db-&gt;conn_id;

//result ID 可以从查询返回的结果对象获取，像这样:
$query = $this-&gt;db-&gt;query(&quot;SOME QUERY&quot;);
$query-&gt;result_id;
</code></pre>
<h1 id="数据库缓存类">数据库缓存类</h1>
<p>把数据库查询结果保存在文本文件中以减少数据库访问.</p>
<p><strong>如何工作？</strong></p>
<p>如果缓存被启用， 当页面第一次加载时，查询结果对象会被序列化并保存到服务器上的一个文本文件中。 当下次再访问该页面时，会直接使用缓存文件而不用访问数据库了，这样， 在已缓存的页面，你的数据库访问会降为 0 。</p>
<p>缓存启用时，本类会被数据库驱动自动加载，切勿手动加载
并非所有查询结果都能被缓存. 只有读类型（SELECT）的查询可以被缓存，因为只有这类查询才会产生结果。 写类型的查询（INSERT、UPDATE 等）并不会生成结果，所以不会被缓存。</p>
<p>缓存文件永不过期，所有的查询只要缓存下来以后除非你删除它们否则将一直可用。 你可以针对特定的页面来删除缓存，或者也可以清空掉所有的缓存。一般来说， 你可以在某些事件发生时（如数据库中添加了数据）用下面的函数来清除缓存。</p>
<p><strong>性能提高？</strong></p>
<p>缓存只是简单的改变了数据获取的途径而已，从访问数据库 变成了访问文件系统</p>
<p>在低负荷而高度优化的数据库应用上，看不到什么效果
随着查询增加，效果慢慢显著. (前提是你的文件系统并没有太多的开销, 在共享的单一服务器环境中，缓存才可能有益)
但在某些场景下，反而由于读取缓存文件 I/O 的问题，会影响性能</p>
<p><strong>缓存文件存储</strong></p>
<p>每个查询都缓存到它单独的缓存文件中，根据调用的控制器方法 缓存文件被进一步组织到各自的子目录中。更准确的说，子目录是使用你 URI 的前两段（控制器名 和 方法名）命名的</p>
<p>例如，你有一个 blog 控制器和一个 comments 方法，并含有三个不同的查询。 缓存系统将创建一个名为 blog+comments 的目录，并在该目录下生成三个 缓存文件。</p>
<p>如果你的 URI 中含有动态查询时（例如使用分页时），每个查询实例都会 生成它单独的缓存文件，因此，最终可能会出现缓存文件数是你页面中的 查询次数的好几倍这样的情况。</p>
<p><strong>管理你的缓存文件</strong></p>
<p>缓存文件不会过期，那么你的应用程序中应该有删除缓存的机制， 例如，我们假设你有一个博客并允许用户评论，每当提交一个新评论时， 你都应该删除掉关于显示评论的那个控制器方法对应的缓存文件（不然产生的缓存文件数量会非常可怕）</p>
<p><strong>不是所有的数据库方法都兼容缓存</strong></p>
<p>无法在缓存的结果对象上使用的：</p>
<ul>
<li>num_fields()</li>
<li>field_names()</li>
<li>field_data()</li>
<li>free_result()</li>
</ul>
<p>同时，result_id 和 conn_id 这两个 id 也无法使用，因为这两个 id 只适用于实时的数据库操作。</p>
<h2 id="启用缓存">启用缓存</h2>
<p>缓存一旦启用，每一次加载页面时，只要该页面含有数据库查询就会自动缓存起来</p>
<ul>
<li>创建一个可写的目录以便保存缓存文件</li>
<li>application/config/database.php 中的 cachedir 参数设置其目录路径；</li>
<li>cache_on 参数设置为 TRUE，</li>
</ul>
<h2 id="函数参考">函数参考</h2>
<h3 id="禁用启用缓存">禁用/启用缓存</h3>
<p><code>$this-&gt;db-&gt;cache_on() / $this-&gt;db-&gt;cache_off()</code> 手工启用/禁用缓存，当你不想缓存某些查询时，这两个方法会很有用</p>
<pre><code class="language-php">// Turn caching on
$this-&gt;db-&gt;cache_on();
$query = $this-&gt;db-&gt;query(&quot;SELECT * FROM mytable&quot;);

// Turn caching off for this one query
$this-&gt;db-&gt;cache_off();
$query = $this-&gt;db-&gt;query(&quot;SELECT * FROM members WHERE member_id = '$current_user'&quot;);

// Turn caching back on
$this-&gt;db-&gt;cache_on();
$query = $this-&gt;db-&gt;query(&quot;SELECT * FROM another_table&quot;);
</code></pre>
<h3 id="删除">删除</h3>
<p>当你更新你的数据库之后需要清除缓存时很有用</p>
<pre><code class="language-php">$this-&gt;db-&gt;cache_delete('blog', 'comments');

</code></pre>
<h3 id="删除全部">删除全部</h3>
<pre><code class="language-php">$this-&gt;db-&gt;cache_delete_all();
</code></pre>
<h1 id="数据库工厂类data-forge">数据库工厂类(Data Forge)</h1>
<p>类似 Laravel 的 Seeder 等</p>
<h2 id="初始化">初始化</h2>
<pre><code class="language-php">$this-&gt;load-&gt;dbforge()

//还可以传另一个数据库对象,返回 dbforge 对象， 而不是直接赋值给 $this-&gt;dbforge 
$this-&gt;myforge = $this-&gt;load-&gt;dbforge($this-&gt;other_db, TRUE);


//一旦初始化结束，你就可以使用 $this-&gt;dbforge 对象来访问它的方法:
$this-&gt;dbforge-&gt;some_method();

</code></pre>
<h2 id="创建和删除数据库">创建和删除数据库</h2>
<pre><code class="language-php">if ($this-&gt;dbforge-&gt;create_database('my_db'))
{
    echo 'Database created!';
}

if ($this-&gt;dbforge-&gt;drop_database('my_db'))
{
    echo 'Database deleted!';
}
</code></pre>
<h2 id="创建删除表">创建/删除表</h2>
<h3 id="先定义字段">先定义字段</h3>
<p>数组中必须包含一个 &lsquo;type&rsquo; 索引，代表字段的数据类型 INT、VARCHAR、TEXT 等
有些数据类型（例如 VARCHAR）还需要加一个 &lsquo;constraint&rsquo; 索引</p>
<p>还可以使用下面的键值对</p>
<p>unsigned/true : 在字段定义中生成 &ldquo;UNSIGNED&rdquo;
default/value : 在字段定义中生成一个默认值
null/true : 在字段定义中生成 &ldquo;NULL&rdquo; ，如果没有这个，字段默认为 &ldquo;NOT NULL&rdquo;
auto_increment/true : 在字段定义中生成自增标识，注意数据类型必须支持这个，例如整型
unique/true : to generate a unique key for the field definition.</p>
<pre><code class="language-php">$fields = array(
    'users' =&gt; array(
        'type' =&gt; 'VARCHAR',
        'constraint' =&gt; '100',
    ),
);

$fields = array(
    'blog_id' =&gt; array(
        'type' =&gt; 'INT',
        'constraint' =&gt; 5,
        'unsigned' =&gt; TRUE,
        'auto_increment' =&gt; TRUE
    ),
    'blog_title' =&gt; array(
        'type' =&gt; 'VARCHAR',
        'constraint' =&gt; '100',
  'unique' =&gt; TRUE,
    ),
    'blog_author' =&gt; array(
        'type' =&gt;'VARCHAR',
        'constraint' =&gt; '100',
        'default' =&gt; 'King of Town',
    ),
    'blog_description' =&gt; array(
        'type' =&gt; 'TEXT',
        'null' =&gt; TRUE,
    ),
);
</code></pre>
<h3 id="添加字段">添加字段</h3>
<p>将前面定义的字段作为参数，来添加字段</p>
<pre><code class="language-php">//$fields = array();
$this-&gt;dbforge-&gt;add_field($fields);

// 或者用字符串形式
$this-&gt;dbforge-&gt;add_field(&quot;label varchar(100) NOT NULL DEFAULT 'default label'&quot;);
//多次调用 add_field() 将会累积。
$this-&gt;dbforge-&gt;add_field(&quot;text varchar(200) NOT NULL DEFAULT 'default text'&quot;);
</code></pre>
<h3 id="创建-id-字段自增主键">创建 id 字段(自增主键)</h3>
<p>和创建其他字段非常不一样，id 字段将会自动定义成类型为 INT(9) 的自增主键。</p>
<pre><code class="language-php">$this-&gt;dbforge-&gt;add_field('id');
// gives id INT(9) NOT NULL AUTO_INCREMENT
</code></pre>
<h3 id="添加键">添加键</h3>
<p>add_key() 方法必须紧跟在 create_table() 方法的后面, 包含多列的非主键必须使用数组来添加.第二个参数可选，可以将其设置为主键</p>
<pre><code class="language-php">$this-&gt;dbforge-&gt;add_key('blog_id', TRUE);
// gives PRIMARY KEY `blog_id` (`blog_id`)

$this-&gt;dbforge-&gt;add_key('blog_id', TRUE);
$this-&gt;dbforge-&gt;add_key('site_id', TRUE);
// gives PRIMARY KEY `blog_id_site_id` (`blog_id`, `site_id`)

$this-&gt;dbforge-&gt;add_key('blog_name');
// gives KEY `blog_name` (`blog_name`)

$this-&gt;dbforge-&gt;add_key(array('blog_name', 'blog_label'));
// gives KEY `blog_name_blog_label` (`blog_name`, `blog_label`)

</code></pre>
<h3 id="创建表">创建表</h3>
<p>字段和键都定义好了之后，开始建表</p>
<pre><code class="language-php">$this-&gt;dbforge-&gt;create_table('table_name');
// gives CREATE TABLE table_name


//第二个参数设置为 TRUE ，可以在定义中添加 &quot;IF NOT EXISTS&quot; 子句。
$this-&gt;dbforge-&gt;create_table('table_name', TRUE);
// gives CREATE TABLE IF NOT EXISTS table_name


//还可以指定表的属性，例如 MySQL 的 ENGINE
$attributes = array('ENGINE' =&gt; 'InnoDB');
$this-&gt;dbforge-&gt;create_table('table_name', FALSE, $attributes);
// produces: CREATE TABLE `table_name` (...) ENGINE = InnoDB DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci
</code></pre>
<h3 id="删除表">删除表</h3>
<pre><code class="language-php">// Produces: DROP TABLE table_name
$this-&gt;dbforge-&gt;drop_table('table_name');

// Produces: DROP TABLE IF EXISTS table_name
$this-&gt;dbforge-&gt;drop_table('table_name',TRUE);
</code></pre>
<h3 id="重命名表">重命名表</h3>
<pre><code class="language-php">$this-&gt;dbforge-&gt;rename_table('old_table_name', 'new_table_name');
// gives ALTER TABLE old_table_name RENAME TO new_table_name
</code></pre>
<h3 id="修改表的列">修改表（的列）</h3>
<pre><code class="language-php">// 添加列
$fields = array(
    'preferences' =&gt; array('type' =&gt; 'TEXT')
);
$this-&gt;dbforge-&gt;add_column('table_name', $fields);
// Executes: ALTER TABLE table_name ADD preferences TEXT

//MySQL 或 CUBIRD ，你可以使用 AFTER 和 FIRST 语句来为新添加的列指定位置
// Will place the new column after the `another_field` column:
$fields = array(
    'preferences' =&gt; array('type' =&gt; 'TEXT', 'after' =&gt; 'another_field')
);

// Will place the new column at the start of the table definition:
$fields = array(
    'preferences' =&gt; array('type' =&gt; 'TEXT', 'first' =&gt; TRUE)
);


// 删除列
$this-&gt;dbforge-&gt;drop_column('table_name', 'column_to_drop');


// 修改列
$fields = array(
    'old_name' =&gt; array(
        'name' =&gt; 'new_name',
        'type' =&gt; 'TEXT',
    ),
);
$this-&gt;dbforge-&gt;modify_column('table_name', $fields);
// gives ALTER TABLE table_name CHANGE old_name new_name TEXT
</code></pre>
<h2 id="类参考-ci_db_forge">类参考 CI_DB_forge</h2>
<h1 id="数据库工具类">数据库工具类</h1>
<h2 id="加载">加载</h2>
<pre><code class="language-php">$this-&gt;load-&gt;dbutil();

// 传另一个数据库对象, 管理的不是你正在使用的数据库
// $this-&gt;myutil = $this-&gt;load-&gt;dbutil($this-&gt;other_db, TRUE);

// 使用
$this-&gt;dbutil-&gt;some_method();

</code></pre>
<h2 id="使用">使用</h2>
<h3 id="获取数据库名称列表">获取数据库名称列表</h3>
<pre><code class="language-php">$dbs = $this-&gt;dbutil-&gt;list_databases();
</code></pre>
<h3 id="判断一个数据库是否存在">判断一个数据库是否存在</h3>
<pre><code class="language-php">if ($this-&gt;dbutil-&gt;database_exists('database_name'))
</code></pre>
<h3 id="优化表">优化表</h3>
<pre><code class="language-php">if ($this-&gt;dbutil-&gt;optimize_table('table_name')){}
</code></pre>
<h3 id="修复表">修复表</h3>
<pre><code class="language-php">if ($this-&gt;dbutil-&gt;repair_table('table_name'))
</code></pre>
<h3 id="优化当前链接的数据库">优化(当前链接的)数据库</h3>
<p>一般只有 MySQL 支持</p>
<pre><code class="language-php">$result = $this-&gt;dbutil-&gt;optimize_database();

if ($result !== FALSE)
{
    print_r($result);
}
</code></pre>
<h3 id="将查询结果导出到-csv--xml-文档">将查询结果导出到 CSV / XML 文档</h3>
<p><strong>该方法并不写入 CSV 文档，它只是简单的返回 CSV 内容, 需要用文件辅助函数写入文件</strong></p>
<p>第二、三、四个参数分别为分隔符、换行符和每个字段包围字符，默认情况下，分隔符为逗号，换行符为 &ldquo;n&rdquo; ， 包围字符为双引号</p>
<pre><code class="language-php">$this-&gt;load-&gt;dbutil();

$query = $this-&gt;db-&gt;query(&quot;SELECT * FROM mytable&quot;);

// csv
echo $this-&gt;dbutil-&gt;csv_from_result($query);

// 修改分隔符
$delimiter = &quot;,&quot;;
$newline = &quot;\r\n&quot;;
$enclosure = '&quot;';
echo $this-&gt;dbutil-&gt;csv_from_result($query, $delimiter, $newline, $enclosure);

// xml
echo $this-&gt;dbutil-&gt;xml_from_result($query, $config);

</code></pre>
<h2 id="备份数据库">备份数据库</h2>
<p>备份完整的数据库或指定的表。备份的数据可以压缩成 Zip 或 Gzip 格式. 只支持 MySQL 和 Interbase/Firebird 数据库。</p>
<pre><code class="language-php">// Load the DB utility class
$this-&gt;load-&gt;dbutil();

// Backup your entire database and assign it to a variable
$backup = $this-&gt;dbutil-&gt;backup();

// Load the file helper and write the file to your server
$this-&gt;load-&gt;helper('file');
write_file('/path/to/mybackup.gz', $backup);

// Load the download helper and send the file to your desktop
$this-&gt;load-&gt;helper('download');
force_download('mybackup.gz', $backup);
</code></pre>
<h3 id="备份参数">备份参数</h3>
<p>备份参数为一个数组，通过第一个参数传递给 backup() 方法</p>
<pre><code class="language-php">$prefs = array(
    'tables'    =&gt; array('table1', 'table2'),   // Array of tables to backup.
    'ignore'    =&gt; array(),         // List of tables to omit from the backup
    'format'    =&gt; 'txt',           // gzip, zip, txt
    'filename'  =&gt; 'mybackup.sql',      // File name - NEEDED ONLY WITH ZIP FILES
    'add_drop'  =&gt; TRUE,            // Whether to add DROP TABLE statements to backup file
    'add_insert'    =&gt; TRUE,            // Whether to add INSERT data to backup file
    'newline'   =&gt; &quot;\n&quot;             // Newline character used in backup file
    // foreign_key_checks =&gt; TRUE  //导出的 SQL 文件中是否继续保持外键约束
);

$this-&gt;dbutil-&gt;backup($prefs);
</code></pre>
<h2 id="类参考--ci_db_utility">类参考  CI_DB_utility</h2>
<h1 id="数据库驱动器参考-ci_db_driver">数据库驱动器参考 CI_DB_driver</h1>
<p>平台无关的数据库实现基类，该类不会被直接调用， 而是通过特定的数据库适配器类来继承和实现该类.</p>
<p>并不是所有的方法都被所有的数据库驱动器所支持， 当不支持的时候，有些方法可能会失败（返回 FALSE）。</p>
<h1 id="查询">查询</h1>
<h2 id="基本查询">基本查询</h2>
<pre><code class="language-php">
// 返回结果集（一个对象），一般在查找数据并需要把返回结果渲染的时候用到
$query = $this-&gt;db-&gt;query('YOUR QUERY HERE');

// 不需要返回，可以在 INSERT DELETE 等时候用到
$this-&gt;db-&gt;query('YOUR QUERY HERE');

</code></pre>
<h2 id="指定数据库前缀">指定数据库前缀</h2>
<p>如果配置了一个数据库前缀参数，想把它加上你的 SQL 语句里的表名前面</p>
<pre><code class="language-php">$this-&gt;db-&gt;dbprefix('tablename'); // outputs prefix_tablename

//想动态的修改这个前缀，而又不希望创建一个新的数据库连接
$this-&gt;db-&gt;set_dbprefix('newprefix');
$this-&gt;db-&gt;dbprefix('tablename'); // outputs newprefix_tablename
</code></pre>
<h2 id="保护标识符--没明白">保护标识符 ?? 没明白</h2>
<p>在很多数据库里，保护表名和字段名是可取的，例如在 MySQL 数据库里使用反引号。 使用查询构造器会自动保护标识符，尽管如此，你还是可以像下面这样手工保护</p>
<pre><code class="language-php">$this-&gt;db-&gt;protect_identifiers('table_name');

//也可以为你的表名添加一个前缀，如果你在数据库配置文件中定义了 dbprefix 参数，通过将这个函数的第二个参数设置为 TRUE 来启用前缀:
$this-&gt;db-&gt;protect_identifiers('table_name', TRUE);

</code></pre>
<p>尽管查询构造器会尽力保护好你输入的表名和字段名，但值得注意的是， 它并不是被设计来处理任意用户输入的，所以，请不要传未处理的数据给它。</p>
<h2 id="转义查询">转义查询</h2>
<p>提交数据到你的数据库之前，确保先对其进行转义(注：另一种说法又说，插入的时候保持格式，输出的时候才转义？)</p>
<pre><code class="language-php">//$this-&gt;db-&gt;escape() 这个函数会检测数据类型，仅转义字符串类型的数据
$sql = &quot;INSERT INTO table (title) VALUES(&quot;.$this-&gt;db-&gt;escape($title).&quot;)&quot;;

//$this-&gt;db-&gt;escape_str() 这个函数忽略数据类型，对传入的数据进行转义， 这个方法并不常用
$sql = &quot;INSERT INTO table (title) VALUES('&quot;.$this-&gt;db-&gt;escape_str($title).&quot;')&quot;;

//$this-&gt;db-&gt;escape_like_str() 这个函数用于处理 LIKE 语句中的字符串，
$search = '20% raise';
$sql = &quot;SELECT id FROM table WHERE column LIKE '%&quot; .
    $this-&gt;db-&gt;escape_like_str($search).&quot;%' ESCAPE '!'&quot;;
</code></pre>
<h2 id="查询绑定简化你查询语法-问号占位符自动被参数替代-以及自动转义提高安全性">查询绑定(简化你查询语法, 问号“占位符”自动被参数替代, 以及自动转义提高安全性)</h2>
<p>好处是：所有的值会被自动转义，生成安全的查询语句。 你不再需要手工进行转义，系统会自动进行。</p>
<pre><code class="language-php">//问号将会自动被第二个参数位置的数组的相应的值替代
$sql = &quot;SELECT * FROM some_table WHERE id = ? AND status = ? AND author = ?&quot;;
$this-&gt;db-&gt;query($sql, array(3, 'live', 'Rick'));

//也可以使用数组的数组 (里面的数组会被转换成 IN 语句的集合）
$sql = &quot;SELECT * FROM some_table WHERE id IN ? AND status = ? AND author = ?&quot;;
$this-&gt;db-&gt;query($sql, array(array(3, 6), 'live', 'Rick'));
</code></pre>
<h2 id="错误处理-1">错误处理</h2>
<pre><code class="language-php">//获取最近一次发生的错误 得到一个包含错误代码和错误消息的数组
if ( ! $this-&gt;db-&gt;simple_query('SELECT `example_field` FROM `example_table`'))
{
    $error = $this-&gt;db-&gt;error(); // Has keys 'code' and 'message'
}
</code></pre>
<h1 id="生成查询结果">生成查询结果</h1>
<h2 id="结果数组">结果数组</h2>
<pre><code class="language-php">$query = $this-&gt;db-&gt;query(&quot;SELECT * FROM users;&quot;);
</code></pre>
<h3 id="以对象数组形式返回查询结果-result">以<strong>对象数组</strong>形式返回查询结果 <code>result()</code></h3>
<p>如果查询失败返回<strong>空数组</strong></p>
<pre><code class="language-php">foreach ($query-&gt;result() as $row){
	echo $row-&gt;title;
}
</code></pre>
<h3 id="将返回对象转成某个类-resultclassname很有用例如拿到用户数据后生成-user-类来访问一些方法">将返回对象转成某个类 <code>result(ClassName)</code>（很有用，例如拿到用户数据后，生成 User 类来访问一些方法！）</h3>
<p>传一个字符串参数给 result() 方法，这个字符串参数代表你想要把每个结果转换成某个类的类名（这个类必须已经加载）</p>
<p>除了可以访问类的成员，还能调用类的方法!</p>
<pre><code class="language-php">foreach ($query-&gt;result('User') as $user){
	echo $user-&gt;name; // access attributes
    echo $user-&gt;reverse_name(); // or methods defined on the 'User' class
}
</code></pre>
<h3 id="返回纯粹的数组-result_array-">返回纯粹的数组 <code>result_array() </code></h3>
<pre><code class="language-php">foreach ($query-&gt;result_array() as $row)
{
    echo $row['title'];
}
</code></pre>
<h3 id="结果行">结果行</h3>
<h4 id="返回单独一行结果对象-如果结果超过一行只取第一行">返回单独一行结果（对象, 如果结果超过一行只取第一行）</h4>
<pre><code class="language-php">$row = $query-&gt;row();
</code></pre>
<h4 id="返回特定行-传递行号作为参数">返回特定行 (传递行号作为参数)</h4>
<pre><code class="language-php">$row = $query-&gt;row(5);
</code></pre>
<h4 id="加上第二个参数结果转换成某个类的类名就像在-resultclassname-的一样">加上第二个参数，结果转换成某个类的类名（就像在 result(ClassName) 的一样）</h4>
<pre><code class="language-php">$query = $this-&gt;db-&gt;query(&quot;SELECT * FROM users LIMIT 1;&quot;);
$row = $query-&gt;row(0, 'User');

echo $row-&gt;name; // access attributes
echo $row-&gt;reverse_name(); // or methods defined on the 'User' class
</code></pre>
<h4 id="row_array-方法-返回纯粹的数组也接收数字参数返回特定行">row_array() 方法, 返回纯粹的数组(也接收数字参数，返回特定行)</h4>
<pre><code class="language-php">$row = $query-&gt;row_array();
if (isset($row))
{
    echo $row['title'];
}

$row = $query-&gt;row_array(5);
</code></pre>
<h4 id="在结果集中获取前后起始结果">在结果集中获取前后、起始结果</h4>
<pre><code class="language-php">// 对象
$row = $query-&gt;first_row()
$row = $query-&gt;last_row()
$row = $query-&gt;next_row()
$row = $query-&gt;previous_row()

// 数组
$row = $query-&gt;first_row('array')
$row = $query-&gt;last_row('array')
$row = $query-&gt;next_row('array')
$row = $query-&gt;previous_row('array')
</code></pre>
<h4 id="处理大结果集时最好使用-unbuffered_row-方法">处理大结果集时最好使用 `unbuffered_row()`` 方法</h4>
<p>上面所有的这些方法都会把所有的结果加载到内存里（预读取)</p>
<p>这个方法和 row() 方法一样返回单独一行结果，但是它不会预读取所有的结果数据到内存中。 如果你的查询结果不止一行，它将<strong>返回当前一行，并通过内部实现的指针来移动到下一行</strong>。</p>
<pre><code class="language-php">$query = $this-&gt;db-&gt;query(&quot;YOUR QUERY&quot;);

while ($row = $query-&gt;unbuffered_row())
{
    echo $row-&gt;title;
}

//为了指定返回值的类型，可以传一个字符串参数 'object'（默认值） 或者 'array' 给这个方法:
$query-&gt;unbuffered_row();       // object
$query-&gt;unbuffered_row('object');   // object
$query-&gt;unbuffered_row('array');    // associative array
</code></pre>
<h4 id="自定义结果对象例如通过转换成类调用一个方法把返回结果中的时间字符串自动格式化">自定义结果对象（例如，通过转换成类，调用一个方法，把返回结果中的时间字符串自动格式化）</h4>
<p>前面提到，可以将返回结果转换成自定义类，并获取到实例的成员和调用方法。(除了 result() result_array() 方法，还有first_row(), last_row(), next_row(), and previous_row() 都可以把返回结果转换成类的实例)</p>
<p>那么假设现在</p>
<ol>
<li>把返回的 <code>$user</code>对象转换撑了 User 类的一个实例</li>
<li>对象中有一个时间类型的字段叫 <code>last_login</code>，值为 &lsquo;15-Feb-2009&rsquo;，想要自动格式化成 &lsquo;15-02-2009&rsquo;</li>
<li>但是这个 User 类也有一个属性叫 <code>last_login</code>, 并且是私有的</li>
<li>如何让它能够在将 <code>$user</code> 对象传入后, 能显示自动格式化后的结果呢？</li>
</ol>
<p><strong>对于非公共成员，类必须要提供一个<code>__set()</code>方法允许设置它们</strong></p>
<pre><code class="language-php">class User {

    public $id;
    public $email;
    public $username;

    protected $last_login;

    public function last_login($format)
    {
        return $this-&gt;last_login-&gt;format($format);
    }

    public function __set($name, $value)
    {
        if ($name === 'last_login')
        {
            $this-&gt;last_login = DateTime::createFromFormat('U', $value);
        }
    }

    public function __get($name)
    {
        if (isset($this-&gt;$name))
        {
            return $this-&gt;$name;
        }
    }
}
</code></pre>
<p>然后 将整个结果集作为所请求类的实例数组返回。惟一的参数是要实例化的类的名称。</p>
<pre><code class="language-php">$query = $this-&gt;db-&gt;query(&quot;YOUR QUERY&quot;);

$rows = $query-&gt;custom_result_object('User');

foreach ($rows as $row)
{
    echo $row-&gt;id;
    echo $row-&gt;email;
    echo $row-&gt;last_login('Y-m-d');
}
</code></pre>
<p>或者一行</p>
<pre><code class="language-php">$row = $query-&gt;custom_row_object(0, 'User');

if (isset($row))
{
    echo $row-&gt;email;   // access attributes
    echo $row-&gt;last_login('Y-m-d');   // access class methods
}
</code></pre>
<h2 id="结果辅助方法行数-列数-释放等">结果辅助方法(行数 列数 释放等)</h2>
<pre><code class="language-php">$query = $this-&gt;db-&gt;query('SELECT * FROM my_table');
</code></pre>
<h3 id="返回查询结果的行数">返回查询结果的行数</h3>
<p>注意：并不是所有的数据库驱动器都有原生的方法来获取查询结果的总行数。 当遇到这种情况时，所有的数据会被预读取到内存中，并调用 count() 函数 来取得总行数（这时可能会有性能问题！）。</p>
<pre><code class="language-php">echo $query-&gt;num_rows();
</code></pre>
<h3 id="返回查询结果的字段数列数">返回查询结果的字段数（列数）</h3>
<pre><code class="language-php">echo $query-&gt;num_fields();
</code></pre>
<h3 id="释放掉查询结果所占的内存并删除结果的资源标识">释放掉查询结果所占的内存，并删除结果的资源标识</h3>
<p>通常来说， PHP 会在脚本执行结束后自动释放内存。但是，如果你在某个脚本中执行大量的查询， 你可能需要在每次查询之后释放掉查询结果，以此来降低内存消耗</p>
<pre><code class="language-php">$query = $this-&gt;db-&gt;query('SELECT title FROM my_table');

foreach ($query-&gt;result() as $row)
{
    echo $row-&gt;title;
}

$query-&gt;free_result();  // The $query result object will no longer be available

$query2 = $this-&gt;db-&gt;query('SELECT name FROM some_table');

$row = $query2-&gt;row();
echo $row-&gt;name;
$query2-&gt;free_result(); // The $query2 result object will no longer be available
</code></pre>
<h3 id="设置下一个结果行的内部指针">设置下一个结果行的内部指针</h3>
<p>它只有在和 unbuffered_row() 方法一起使用才有效果。</p>
<p>接受一个正整数参数（默认值为0）表示想要读取的下一行，返回值为 TRUE 或 FALSE 表示成功或失败</p>
<p><strong>注意</strong> 并不是所有的数据库驱动器都支持这一特性，调用这个方法将会返回 FALSE， 例如你<strong>无法在 PDO 上使用它</strong>。</p>
<pre><code class="language-php">$query-&gt;data_seek(5); // Skip the first 5 rows
$row = $query-&gt;unbuffered_row();
</code></pre>
<h2 id="完整的-ci_db_result-类参考">完整的 <code>CI_DB_result</code> 类参考</h2>
<ul>
<li><code>result([$type = 'object'])</code></li>
<li><code>result_array()</code>
&hellip;.略</li>
</ul>
<h1 id="查询辅助函数">查询辅助函数</h1>
<h2 id="关于执行查询的信息">关于执行查询的信息</h2>
<pre><code class="language-php">//执行 INSERT 语句时，这个方法返回新插入行的ID  
//[TODO 待查] PostgreSQL 的 PDO 驱动器, 或者 Interbase 驱动器， 这个方法需要一个 $name 参数来指定合适的顺序。(???)
$this-&gt;db-&gt;insert_id()

//执行 INSERT、UPDATE 等写类型的语句时，这个方法返回受影响的行数
//默认MySQL 中执行 &quot;DELETE FROM TABLE&quot; 语句返回受影响的行数为 0 ,为了看起来更直观，CI 的数据库类做了点小 hack,并不是 MySQL原生的返回结果
$this-&gt;db-&gt;affected_rows()

//返回上一次执行的查询语句 (配置文件中的 save_queries 设置为 FALSE 可以让这个方法无效)
$this-&gt;db-&gt;last_query()
</code></pre>
<h2 id="关于数据库的信息">关于数据库的信息</h2>
<pre><code class="language-php">//获取数据表的总行数
$this-&gt;db-&gt;count_all()

// 输出你正在使用的数据库平台（MySQL，MS SQL，Postgres 等）
$this-&gt;db-&gt;platform()

//数据库版本:
$this-&gt;db-&gt;version()
</code></pre>
<h2 id="让你的查询更简单根据数据组装格式化-sql">让你的查询更简单(根据数据，组装、格式化 SQL)</h2>
<p>所有的值自动被转义，生成安全的查询语句。</p>
<pre><code class="language-php">//简化了 INSERT 语句的书写，它返回一个正确格式化的 INSERT 语句
$data = array('name' =&gt; $name, 'email' =&gt; $email, 'url' =&gt; $url);
$str = $this-&gt;db-&gt;insert_string('table_name', $data);

// 生成的 SQL 语句 INSERT INTO table_name (name, email, url) VALUES ('Rick', 'rick@example.com', 'example.com')


// 简化了 UPDATE 语句的书写，它返回一个正确格式化的 UPDATE 语句
$data = array('name' =&gt; $name, 'email' =&gt; $email, 'url' =&gt; $url);
$where = &quot;author_id = 1 AND status = 'active'&quot;;
$str = $this-&gt;db-&gt;update_string('table_name', $data, $where);

// 生成语句 UPDATE table_name SET name = 'Rick', email = 'rick@example.com', url = 'example.com' WHERE author_id = 1 AND status = 'active'

</code></pre>
<h1 id="查询构造器快捷方法简化查询">查询构造器（快捷方法简化查询）</h1>
<h2 id="查询-1">查询</h2>
<h3 id="get-全表数据">get() 全表数据</h3>
<pre><code class="language-php">//执行 SELECT 语句并返回查询结果,得到一个表的所有数据，然后就可以从 $query 变量得到查询结果
$query = $this-&gt;db-&gt;get('mytable');
// 设置 limit (2、3 个参数)
$query = $this-&gt;db-&gt;get('mytable', 10, 20);

//仅编译 SELECT 查询并返回查询的 SQL 语句，不执行
$sql = $this-&gt;db-&gt;get_compiled_select('mytable');
echo $sql;
</code></pre>
<h3 id="select-限制查询的字段列表">select() 限制查询的字段列表</h3>
<p>如果你要查询表的所有列，可以不用写这个函数，CodeIgniter 会自动查询所有列（SELECT *）。
但有时候为了提高查询效率，只需要找出几个需要的字段就行了</p>
<pre><code class="language-php">// 相当于 SELECT title, content, date FROM mytable
$this-&gt;db-&gt;select('title, content, date');
$query = $this-&gt;db-&gt;get('mytable');
</code></pre>
<p>第二个参数可选，如果设置为 FALSE，CodeIgniter 将不保护你的 表名和字段名，这在当你编写复合查询语句时很有用，不会破坏你编写的语句。
(这个“保护”到底是啥意思？)</p>
<pre><code class="language-php">$this-&gt;db-&gt;select('(SELECT SUM(payments.amount) FROM payments WHERE payments.invoice_id=4) AS amount_paid', FALSE);
$query = $this-&gt;db-&gt;get('mytable');
</code></pre>
<h3 id="重置查询的问题">重置查询的问题</h3>
<p>使用 <code>$this-&gt;db-&gt;get()</code> 方法查询会被执行并默认被重置， 使用 <code>$this-&gt;db-&gt;reset_query()</code> 方法直接重置</p>
<pre><code class="language-php">//第二个参数用于设置是否重置查询（默认会）,例如下面的，设为 FALSE, 不重置
//所以会把前面那条 SQL 打印出来: SELECT * FROM mytable LIMIT 20, 10
echo $this-&gt;db-&gt;limit(10,20)-&gt;get_compiled_select('mytable', FALSE);

// 注意下面这条奇怪的语句，它打印了 
// SELECT title, content, date FROM mytable LIMIT 20, 10
// 里面有 &quot;FROM mytable&quot; 子句
// 奇怪 并没指定数据表是哪个（db-&gt;from()）,却能找到表？
// 这是因为前面的查询没有被重置，因此能拿到之前 -&gt;get('mytable') 生成的表名信息
echo $this-&gt;db-&gt;select('title, content, date')-&gt;get_compiled_select();
</code></pre>
<h3 id="get_where-条件查询">get_where() 条件查询</h3>
<p>它提供了第二个参数可以让你添加一个 WHERE 子句， 而不是使用 <code>db-&gt;where()</code> 方法:</p>
<pre><code class="language-php">$query = $this-&gt;db-&gt;get_where('mytable', array('id' =&gt; $id), $limit, $offset);

</code></pre>
<h3 id="select_maxselect_minselect_avg-select_sum-某个字段所有列中的最大值-最小值-平均值-求和"><code>select_max()，select_min()，select_avg() select_sum()</code> 某个字段所有列中的最大值 最小值 平均值 求和</h3>
<p>编写 <code>SELECT MAX(field)</code> 部分(或 MIN(field))</p>
<p>第二个参数（可选）重命名结果字段</p>
<pre><code class="language-php">$this-&gt;db-&gt;select_max('age');
$query = $this-&gt;db-&gt;get('members');  // Produces: SELECT MAX(age) as age FROM members

$this-&gt;db-&gt;select_max('age', 'member_age');
$query = $this-&gt;db-&gt;get('members'); // Produces: SELECT MAX(age) as member_age FROM members

$this-&gt;db-&gt;select_avg('age');
$query = $this-&gt;db-&gt;get('members'); // Produces: SELECT AVG(age) as age FROM members

$this-&gt;db-&gt;select_sum('age');
$query = $this-&gt;db-&gt;get('members'); // Produces: SELECT SUM(age) as age FROM members
</code></pre>
<h3 id="from">from()</h3>
<p>编写查询语句中的 FROM 子句:</p>
<pre><code class="language-php">$this-&gt;db-&gt;select('title, content, date');
$this-&gt;db-&gt;from('mytable');
$query = $this-&gt;db-&gt;get();  // Produces: SELECT title, content, date FROM mytable
</code></pre>
<p>前面提到过，还可在 <code>db-&gt;get('tableName')</code> 中指定 相当于两句 <code>db-&gt;from('tableName'); db-&gt;get();</code></p>
<h3 id="join">join()</h3>
<pre><code class="language-php">$this-&gt;db-&gt;select('*');
$this-&gt;db-&gt;from('blogs');
$this-&gt;db-&gt;join('comments', 'comments.id = blogs.id');
$query = $this-&gt;db-&gt;get();

// Produces:
// SELECT * FROM blogs JOIN comments ON comments.id = blogs.id

//传入第三个参数指定连接的类型，有这样几种选择：left，right，outer，inner，left outer 和 right outer 。
$this-&gt;db-&gt;join('comments', 'comments.id = blogs.id', 'left');
// Produces: LEFT JOIN comments ON comments.id = blogs.id
</code></pre>
<p>如果查询中有多个连接，你可以多次调用</p>
<h2 id="搜索">搜索</h2>
<h3 id="where-和-or_where">where() 和 or_where()</h3>
<p>所有的数据将会自动转义，生成安全的查询语句。</p>
<pre><code class="language-php">//可以用 key/value 方式, 如果是多条 where, 自动加上 AND
$this-&gt;db-&gt;where('name', $name);
$this-&gt;db-&gt;where('title', $title);
$this-&gt;db-&gt;where('status', $status);
// WHERE name = 'Joe' AND title = 'boss' AND status = 'active'

// 除了“等于”，在第一个参数可以用比较运算符 (同样可以连续多个 where 来 AND)
$this-&gt;db-&gt;where('name !=', $name);
$this-&gt;db-&gt;where('id &lt;', $id); 
// Produces: WHERE name != 'Joe' AND id &lt; 45

//如果不想写那么多行，可以传入一个关联数组
$array = array('name' =&gt; $name, 'title' =&gt; $title, 'status' =&gt; $status);
$this-&gt;db-&gt;where($array);
// Produces: WHERE name = 'Joe' AND title = 'boss' AND status = 'active'

// 或者干脆全部手写 WHERE 子句
$where = &quot;name='Joe' AND status='boss' OR status='active'&quot;;
$this-&gt;db-&gt;where($where);
</code></pre>
<p>如果希望把 AND 改成 OR, 那就用 or_where()</p>
<pre><code class="language-php">$this-&gt;db-&gt;where('name !=', $name);
$this-&gt;db-&gt;or_where('id &gt;', $id);  // Produces: WHERE name != 'Joe' OR id &gt; 50
</code></pre>
<h3 id="where_in-与-or_where_in-还有-where_not_in-or_where_not_in">where_in() 与 or_where_in() 还有 where_not_in() or_where_not_in()</h3>
<pre><code class="language-php">$names = array('Frank', 'Todd', 'James');
$this-&gt;db-&gt;where_in('username', $names);
// Produces: WHERE username IN ('Frank', 'Todd', 'James')


$names = array('Frank', 'Todd', 'James');
$this-&gt;db-&gt;or_where_in('username', $names);
// Produces: OR username IN ('Frank', 'Todd', 'James')


$names = array('Frank', 'Todd', 'James');
$this-&gt;db-&gt;where_not_in('username', $names);
// Produces: WHERE username NOT IN ('Frank', 'Todd', 'James')


$names = array('Frank', 'Todd', 'James');
$this-&gt;db-&gt;or_where_not_in('username', $names);
// Produces: OR username NOT IN ('Frank', 'Todd', 'James')
</code></pre>
<h2 id="模糊搜索-like-与-or_like-not_like--or_not_like">模糊搜索 like() 与 or_like() not_like()  or_not_like()</h2>
<p>可以灵活组合</p>
<pre><code class="language-php">$this-&gt;db-&gt;like('title', 'match');

$array = array('title' =&gt; $match, 'page1' =&gt; $match, 'page2' =&gt; $match);
$this-&gt;db-&gt;like($array);
// WHERE `title` LIKE '%match%' ESCAPE '!' AND  `page1` LIKE '%match%' ESCAPE '!' AND  `page2` LIKE '%match%' ESCAPE '!'


//默认 % 通配符会在前后都添加，如果要指定，可以第三个可选的参数来控制 LIKE 通配符（%）的位置
$this-&gt;db-&gt;like('title', 'match', 'before');    // Produces: WHERE `title` LIKE '%match' ESCAPE '!'
$this-&gt;db-&gt;like('title', 'match', 'after'); // Produces: WHERE `title` LIKE 'match%' ESCAPE '!'
$this-&gt;db-&gt;like('title', 'match', 'both');  // Produces: WHERE `title` LIKE '%match%' ESCAPE '!'

 
$this-&gt;db-&gt;or_like('body', $match);
// WHERE `title` LIKE '%match%' ESCAPE '!' OR  `body` LIKE '%match%' ESCAPE '!'


$this-&gt;db-&gt;not_like('title', 'match');  // WHERE `title` NOT LIKE '%match% ESCAPE '!'


$this-&gt;db-&gt;or_not_like('body', 'match');
// WHERE `title` LIKE '%match% OR  `body` NOT LIKE '%match%' ESCAPE '!'
</code></pre>
<h2 id="group_by-分组">group_by() 分组</h2>
<pre><code class="language-php">$this-&gt;db-&gt;group_by(&quot;title&quot;); // Produces: GROUP BY title

// 多个值
$this-&gt;db-&gt;group_by(array(&quot;title&quot;, &quot;date&quot;));  // Produces: GROUP BY title, date

</code></pre>
<h2 id="distinct">distinct()</h2>
<pre><code class="language-php">$this-&gt;db-&gt;distinct();
$this-&gt;db-&gt;get('table'); // Produces: SELECT DISTINCT * FROM table
</code></pre>
<h2 id="having-与-or_having">having() 与 or_having()</h2>
<pre><code class="language-php">$this-&gt;db-&gt;having('user_id = 45');  // Produces: HAVING user_id = 45
$this-&gt;db-&gt;having('user_id',  45);  // Produces: HAVING user_id = 45

$this-&gt;db-&gt;having(array('title =' =&gt; 'My Title', 'id &lt;' =&gt; $id));
// Produces: HAVING title = 'My Title', id &lt; 45


//如果 CodeIgniter 自动转义你的查询，为了避免转义，你可以将第三个参数设置为 FALSE 
$this-&gt;db-&gt;having('user_id',  45);  // Produces: HAVING `user_id` = 45 in some databases such as MySQL
$this-&gt;db-&gt;having('user_id',  45, FALSE);  // Produces: HAVING user_id = 45
</code></pre>
<h2 id="排序-order_by">排序 order_by()</h2>
<pre><code class="language-php">$this-&gt;db-&gt;order_by('title', 'DESC');
// Produces: ORDER BY `title` DESC


//根据多个字段进行排序
$this-&gt;db-&gt;order_by('title', 'DESC');
$this-&gt;db-&gt;order_by('name', 'ASC');
// Produces: ORDER BY `title` DESC, `name` ASC

// 除了上面把字段、排序方式分开写，也支持一个复杂的排序字符串. 这里和上面的一致
$this-&gt;db-&gt;order_by('title DESC, name ASC');
// Produces: ORDER BY `title` DESC, `name` ASC
</code></pre>
<h3 id="random-随机排序">RANDOM （随机排序）</h3>
<p>第一个参数会被忽略，但是你可以传入一个 数字值，作为随机数的 seed
(Oracle 暂时还不支持随机排序)</p>
<pre><code class="language-php">$this-&gt;db-&gt;order_by('title', 'RANDOM');
// Produces: ORDER BY RAND()

$this-&gt;db-&gt;order_by(42, 'RANDOM');
// Produces: ORDER BY RAND(42)
</code></pre>
<h2 id="分页与计数">分页与计数</h2>
<h3 id="分页限制-limit">分页限制 limit()</h3>
<pre><code class="language-php">$this-&gt;db-&gt;limit(10);  // Produces: LIMIT 10
$this-&gt;db-&gt;limit(10, 20); // 第二个参数是偏移

// 之前 get() 里可以简写
$this-&gt;db-&gt;get('table', 10, 20);
</code></pre>
<h3 id="计数--count_all_results-与">计数  count_all_results() 与</h3>
<p>用于获取特定查询返回结果的数量</p>
<pre><code class="language-php">echo $this-&gt;db-&gt;count_all_results('my_table');  // Produces an integer, like 25
$this-&gt;db-&gt;like('title', 'match');
$this-&gt;db-&gt;from('my_table');
echo $this-&gt;db-&gt;count_all_results(); // Produces an integer, like 17

//这个方法会重置你在 select() 方法里设置的所有值，如果你希望保留它们，可以将 第二个参数设置为 FALSE
echo $this-&gt;db-&gt;count_all_results('my_table', FALSE);

//获取某个表的总行数  (和 count_all_results() 不指定查询条件的区别是啥？)
echo $this-&gt;db-&gt;count_all('my_table');  // Produces an integer, like 25

</code></pre>
<h2 id="查询条件组-group_start-group_end等-生成用括号括起来的一组-where-条件支持嵌套">查询条件组 group_start() group_end()等 生成用括号括起来的一组 WHERE 条件(支持嵌套)</h2>
<p>条件组必须要配对，确保每个 group_start() 方法都有一个 group_end() 方法与之配对。</p>
<p>相当于添加括号。</p>
<pre><code class="language-php">$this-&gt;db-&gt;select('*')-&gt;from('my_table')
    -&gt;group_start()
        -&gt;where('a', 'a')
        -&gt;or_group_start()
            -&gt;where('b', 'b')
            -&gt;where('c', 'c')
        -&gt;group_end()
    -&gt;group_end()
    -&gt;where('d', 'd')
-&gt;get();

// Generates:
// SELECT * FROM (`my_table`) WHERE ( `a` = 'a' OR ( `b` = 'b' AND `c` = 'c' ) ) AND `d` = 'd'
</code></pre>
<h2 id="插入数据">插入数据</h2>
<h3 id="insert-与-批量插入-insert_batch">insert() 与 批量插入 insert_batch()</h3>
<p>参数是一个<strong>数组</strong> 或一个<strong>对象</strong></p>
<pre><code class="language-php">$data = array(
    'title' =&gt; 'My title',
    'name' =&gt; 'My Name',
    'date' =&gt; 'My date'
);

// 或者对象
/*
class Myclass {
    public $title = 'My Title';
    public $content = 'My Content';
    public $date = 'My Date';
}
*/

$object = new Myclass;

$this-&gt;db-&gt;insert('mytable', $data);
// Produces: INSERT INTO mytable (title, name, date) VALUES ('My title', 'My name', 'My date')

</code></pre>
<p>批量插入</p>
<pre><code class="language-php">$data = array(
    array(
        'title' =&gt; 'My title',
        'name' =&gt; 'My Name',
        'date' =&gt; 'My date'
    ),
    array(
        'title' =&gt; 'Another title',
        'name' =&gt; 'Another Name',
        'date' =&gt; 'Another date'
    )
);

$this-&gt;db-&gt;insert_batch('mytable', $data);
// Produces: INSERT INTO mytable (title, name, date) VALUES ('My title', 'My name', 'My date'),  ('Another title', 'Another name', 'Another date')
</code></pre>
<h3 id="get_compiled_insert-生成一条-insert-语句但是并不执行">get_compiled_insert() 生成一条 INSERT 语句，但是并不执行</h3>
<p><code>$this-&gt;db-&gt;insert()</code> 方法类似,</p>
<pre><code class="language-php">$data = array(
   'title' =&gt; 'My title',
   'name'  =&gt; 'My Name',
   'date'  =&gt; 'My date'
);

$sql = $this-&gt;db-&gt;set($data)-&gt;get_compiled_insert('mytable');
echo $sql;

// Produces string: INSERT INTO mytable (`title`, `name`, `date`) VALUES ('My title', 'My name', 'My date')
</code></pre>
<p>第二个参数用于设置是否重置查询.</p>
<p>第一句执行的时候， <strong>先执行（打印当前 set() 的数据）</strong>，然后再标记“不重置”  有点像之前学 C 语言的的 <code>i++</code>
所以第二句即使 set 了新数据（<code>content</code>），仍然会把第一句 set 的数据 <code>title</code> 给打印出来</p>
<pre><code class="language-php">echo $this-&gt;db-&gt;set('title', 'My Title')-&gt;get_compiled_insert('mytable', FALSE);

// Produces string: INSERT INTO mytable (`title`) VALUES ('My Title')

echo $this-&gt;db-&gt;set('content', 'My Content')-&gt;get_compiled_insert();

// Produces string: INSERT INTO mytable (`title`, `content`) VALUES ('My Title', 'My Content')
</code></pre>
<h2 id="更新数据">更新数据</h2>
<h3 id="replace-语句快速完成-selectupdatedelete-以及-insert的组合">replace() 语句快速完成 select()，update()，delete() 以及 insert()的组合</h3>
<p>REPLACE 语句根据表的<strong>主键</strong>和<strong>唯一索引</strong> 来执行，类似于标准的 DELETE + INSERT</p>
<pre><code class="language-php">//假设 title 字段是我们的主键，那么如果我们数据库里有一行 的 title 列的值为 'My title'，这一行将会被删除并被我们的新数据所取代
$data = array(
    'title' =&gt; 'My title',
    'name'  =&gt; 'My Name',
    'date'  =&gt; 'My date'
);

$this-&gt;db-&gt;replace('table', $data);

// Executes: REPLACE INTO mytable (title, name, date) VALUES ('My title', 'My name', 'My date')

</code></pre>
<h3 id="update-与-update_batch">update() 与 update_batch()</h3>
<p><strong>切记，小心全部数据被替换的问题</strong>*</p>
<p>千万要记得，加上一个 <code>where()</code>来限制更新的范围</p>
<p>同样支持数组/对象</p>
<pre><code class="language-php">$data = array(
    'title' =&gt; $title,
    'name' =&gt; $name,
    'date' =&gt; $date
);

$this-&gt;db-&gt;where('id', $id);
$this-&gt;db-&gt;update('mytable', $data);
// Produces:
//
//  UPDATE mytable
//  SET title = '{$title}', name = '{$name}', date = '{$date}'
//  WHERE id = $id
</code></pre>
<p>如果不想单独写 where() 一样，可以在 update() 里作为第三个参数传入</p>
<pre><code class="language-php">$this-&gt;db-&gt;update('mytable', $data, &quot;id = 4&quot;);
$this-&gt;db-&gt;update('mytable', $data, array('id' =&gt; $id));

</code></pre>
<p>批量更新</p>
<pre><code class="language-php">$data = array(
   array(
      'title' =&gt; 'My title' ,
      'name' =&gt; 'My Name 2' ,
      'date' =&gt; 'My date 2'
   ),
   array(
      'title' =&gt; 'Another title' ,
      'name' =&gt; 'Another Name 2' ,
      'date' =&gt; 'Another date 2'
   )
);

$this-&gt;db-&gt;update_batch('mytable', $data, 'title');

// Produces:
// UPDATE `mytable` SET `name` = CASE
// WHEN `title` = 'My title' THEN 'My Name 2'
// WHEN `title` = 'Another title' THEN 'Another Name 2'
// ELSE `name` END,
// `date` = CASE
// WHEN `title` = 'My title' THEN 'My date 2'
// WHEN `title` = 'Another title' THEN 'Another date 2'
// ELSE `date` END
// WHERE `title` IN ('My title','Another title')
</code></pre>
<h3 id="set-设置新增或更新的数据">set() 设置新增或更新的数据</h3>
<p>可以取代直接传递数据数组到 insert() 或 update() 方法</p>
<pre><code class="language-php">$this-&gt;db-&gt;set('name', $name);

// 当然了，可以继续多次设置值
$this-&gt;db-&gt;set('title', $title);
$this-&gt;db-&gt;set('status', $status);

// 第三个参数，如果设置为 FALSE，数据将不会自动转义
$this-&gt;db-&gt;set('field', 'field+1', FALSE);

// 开始调用 insert()
$this-&gt;db-&gt;insert('mytable');  // Produces: INSERT INTO mytable (`name`) VALUES ('{$name}')

// 以及 update()
$this-&gt;db-&gt;update('mytable');

// 接受一个关联数组作为参数，一次性搞定不需要多行
$array = array(
    'name' =&gt; $name,
    'title' =&gt; $title,
    'status' =&gt; $status
);

$this-&gt;db-&gt;set($array);
$this-&gt;db-&gt;insert('mytable');
</code></pre>
<h3 id="关于-set-第三个参数是否转义-产生的很有意思的问题">关于 set() 第三个参数是否转义 产生的很有意思的问题</h3>
<p>set() 方法也接受可选的第三个参数（$escape），如果设置为 FALSE，数据将不会自动转义</p>
<p>看一个例子</p>
<pre><code class="language-php">$this-&gt;db-&gt;set('field', 'field+1', FALSE);
$this-&gt;db-&gt;where('id', 2);
$this-&gt;db-&gt;update('mytable'); // gives UPDATE mytable SET field = field+1 WHERE id = 2

$this-&gt;db-&gt;set('field', 'field+1');
$this-&gt;db-&gt;where('id', 2);
$this-&gt;db-&gt;update('mytable'); // gives UPDATE `mytable` SET `field` = 'field+1' WHERE `id` = 2
</code></pre>
<p>第一段中不转义（就是值 &ldquo;field+1&rdquo; 不使用引号包裹，直接拼接到 SQL 中去），由于正好表里面有个 field 字段，导致结果是 <strong>field 值自增1</strong>，
还会导致什么情况呢？
假设现在值为 &ldquo;another_field+1&rdquo;  在运行 SQL 的时候，由于表可能没有这个<code>another_field</code>字段，会运行报错！</p>
<p>第二段启用了转义（值 &ldquo;field+1&rdquo; 用引号包裹，作为一个整体赋值给 field 字段， 因此结果是 <strong>field 的值变成了新的字符串</strong>）</p>
<h3 id="get_compiled_update-略-和-insert一样">get_compiled_update() 略 和 &hellip;insert&hellip;一样</h3>
<h2 id="删除数据">删除数据</h2>
<h3 id="delete-从表中删除符合条件的数据">delete() 从表中删除符合条件的数据</h3>
<p>和更新数据一样，<strong>一定要用 where() / or_where() 限制范围</strong>， 除非你不想活了（划掉）</p>
<pre><code class="language-php">$this-&gt;db-&gt;delete('mytable', array('id' =&gt; $id));  // Produces: // DELETE FROM mytable  // WHERE id = $id

</code></pre>
<h3 id="从-多个表-中同时删除数据">从 多个表 中同时删除数据</h3>
<pre><code class="language-php">$tables = array('table1', 'table2', 'table3');
$this-&gt;db-&gt;where('id', '5');
$this-&gt;db-&gt;delete($tables);
</code></pre>
<h3 id="删除一个表中的所有数据清空">删除一个表中的所有数据（清空）</h3>
<pre><code class="language-php">// 生成 DELETE 语句并执行，自增id不会恢复
$this-&gt;db-&gt;empty_table('mytable'); // Produces: DELETE FROM mytable

// TRUNCATE ， 自增id恢复到1
$this-&gt;db-&gt;truncate('mytable');

</code></pre>
<h3 id="get_compiled_delete-略">get_compiled_delete() 略</h3>
<h2 id="链式方法-多个方法连接在一起-大大的简化语法">链式方法: 多个方法连接在一起 大大的简化语法</h2>
<p>不早说！现在有点像 Laravel 了。。。</p>
<pre><code class="language-php">$query = $this-&gt;db-&gt;select('title')
        -&gt;where('id', $id)
        -&gt;limit(10, 20)
        -&gt;get('mytable');
</code></pre>
<h2 id="查询构造器缓存">查询构造器缓存</h2>
<p>注意这不是 &ldquo;真正的&rdquo; 缓存</p>
<p>查询构造器允许你将查询的某个特定部分保存（或 &ldquo;缓存&rdquo;）起来， 以便在你的脚本执行之后重用。</p>
<p>一般情况下，当查询构造器的一次调用结束后，所有已存储的信息 都会被重置，以便下一次调用。</p>
<p>如果开启缓存，你就可以使信息避免被重置，方便你进行重用。</p>
<p>支持缓存的查询类型有： select, from, join, where, like, group_by, having, order_by</p>
<p>？？？ 这句没看懂</p>
<blockquote>
<p>缓存调用是累加的。如果你调用了两次有缓存的 select()，然后再调用两次没有缓存的 select()， 这会导致 select() 被调用4次。</p>
</blockquote>
<pre><code class="language-php">//如需开启缓存必须先调用此方法，所有支持的查询类型都会被存储起来供以后使用
$this-&gt;db-&gt;start_cache();
$this-&gt;db-&gt;select('field1');
//此方法用于停止缓存。
$this-&gt;db-&gt;stop_cache();
$this-&gt;db-&gt;get('tablename');
//Generates: SELECT `field1` FROM (`tablename`)

$this-&gt;db-&gt;select('field2');
$this-&gt;db-&gt;get('tablename');
//Generates:  SELECT `field1`, `field2` FROM (`tablename`)

//此方法用于清空缓存
$this-&gt;db-&gt;flush_cache();
$this-&gt;db-&gt;select('field2');
$this-&gt;db-&gt;get('tablename');
//Generates:  SELECT `field2` FROM (`tablename`)
</code></pre>
<h2 id="重置查询构造器-reset_query">重置查询构造器 reset_query()</h2>
<p>该方法无需执行就能重置查询构造器中的查询，<code>$this-&gt;db-&gt;get()</code> 和 <code>$this-&gt;db-&gt;insert()</code> 方法也可以用于重置查询，但是必须要先执行它。</p>
<p>和这两个方法一样，使用<code>查询构造器缓存</code> 缓存下来的查询不会被重置。</p>
<p>通常使用查询构造器生成 SQL 语句（如：$this-&gt;db-&gt;get_compiled_select()）之后再执行它。这种情况下，不重置查询缓存将非常有用:</p>
<pre><code class="language-php">// Note that the second parameter of the get_compiled_select method is FALSE
$sql = $this-&gt;db-&gt;select(array('field1','field2'))
                -&gt;where('field3',5)
                -&gt;get_compiled_select('mytable', FALSE);

// ...
// Do something crazy with the SQL code... like add it to a cron script for
// later execution or something...
// ...

$data = $this-&gt;db-&gt;get()-&gt;result_array();

// Would execute and return an array of results of the following query:
// SELECT field1, field1 from mytable where field3 = 5;
</code></pre>
<blockquote>
<p>如果你正在使用查询构造器缓存功能，连续两次调用 get_compiled_select() 方法 并且不重置你的查询，这将会导致缓存被合并两次。举例来说，例如你正在缓存 select() 方法，那么会查询两个相同的字段。</p>
</blockquote>
<h2 id="类参考-class-ci_db_query_builder">类参考 class CI_DB_query_builder</h2>

    </div>
    <div class="article-footer">
<blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接: </strong>
      <a href="https://my101du.github.io/1/01/codeigniter-%E6%95%B0%E6%8D%AE%E5%BA%93/" title="" target="_blank" rel="external">https://my101du.github.io/1/01/codeigniter-%E6%95%B0%E6%8D%AE%E5%BA%93/</a>
    </li>
    <li class="post-copyright-license">
      <strong>License：</strong><a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN</a>
    </li>
  </ul>
</blockquote>

<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/my101du" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="https://avatars2.githubusercontent.com/u/1332645?s=460&amp;u=dc114d6baad010456a5af87c4cc2df0694ff2b1c&amp;v=4" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/my101du" target="_blank"><span class="text-dark">my101du</span><small class="ml-1x"></small></a></h3>
        <div>Stay Hungry, Stay Foolish</div>
      </div>
    </figure>
  </div>
</div>
    </div>
  </article>
<section id="comments">
</section>

</div><nav class="bar bar-footer clearfix" data-stick-bottom>
    <div class="bar-inner">
        <ul class="pager pull-left">
            <li class="prev">
                <a href="https://my101du.github.io/1/01/codeigniter-%E7%B1%BB%E5%BA%93%E4%B8%8E%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0-topics/" title=""><i
                        class="icon icon-angle-left"
                        aria-hidden="true"></i><span>&nbsp;&nbsp;下一篇</span></a>
            </li>
            <li class="next">
                <a href="https://my101du.github.io/1/01/codeigniter-%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8A%80%E5%B7%A7/"
                    title=""><span>上一篇&nbsp;&nbsp;</span><i
                        class="icon icon-angle-right" aria-hidden="true"></i></a>
            </li>
            
            <li class="toggle-toc">
                <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false"
                    title="文章目录" role="button">
                    <span>[&nbsp;</span><span>文章目录</span>
                    <i class="text-collapsed icon icon-anchor"></i>
                    <i class="text-in icon icon-close"></i>
                    <span>]</span>
                </a>
            </li>
        </ul>
        <div class="bar-right">
            <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter"
                data-mobile-sites="weibo,qq,qzone"></div>
        </div>
    </div>
</nav>

</main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
<ul class="social-links">
    <li><a href="https://github.com/my101du" target="_blank" title="github" data-toggle=tooltip data-placement=top >
            <i class="icon icon-github"></i></a></li>
    <li><a href="https://my101du.github.io/index.xml" target="_blank" title="rss" data-toggle=tooltip data-placement=top >
            <i class="icon icon-rss"></i></a></li>
</ul>
  <div class="copyright">
    &copy;2017  -
    2020
    <div class="publishby">
        Theme by <a href="https://github.com/xiaoheiAh" target="_blank"> xiaoheiAh </a>base on<a href="https://github.com/xiaoheiAh/hugo-theme-pure" target="_blank"> pure</a>.
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
            showMathMenu: false, //disables context menu
            tex2jax: {
            inlineMath: [ ['$','$'], ['\\(','\\)'] ]
           }
    });
</script>


<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
<script>
    window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>
<script type="text/javascript" src="https://cdn.staticfile.org/highlight.js/9.15.10/highlight.min.js"></script>
<script type="text/javascript" src="https://cdn.staticfile.org/highlight.js/9.15.10/languages/javascript.min.js" defer></script>
<script type="text/javascript" src="https://cdn.staticfile.org/highlight.js/9.15.10/languages/php.min.js" defer></script><script>
    hljs.configure({
        tabReplace: '    ', 
        classPrefix: ''     
        
    })
    hljs.initHighlightingOnLoad();
</script>
<script src="https://my101du.github.io/js/application.min.bdeb64b910570b6c41badc6a05b7afb0c8ad9efd8525de3c7257d59e786326a3.js"></script>
<script src="https://my101du.github.io/js/plugin.min.51ff8c7317566f82259170fa36e09c4493adc9b9378b427a01ad3f017ebac7dd.js"></script>

<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(未命名)',
            },
            ROOT_URL: 'https:\/\/my101du.github.io\/',
            CONTENT_URL: 'https:\/\/my101du.github.io\/\/searchindex.json ',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script type="text/javascript" src="https://my101du.github.io/js/insight.min.a343cd9a5a7698336b28ef3a7c16a3a1b1d2d5fb17dc8ed04022bbe08cc5459073a15bdafa3a8a58cdd56080784bdd69fa70b1ae8597565c799c57ed00f0e120.js" defer></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
<script>
    tocbot.init({
        
        tocSelector: '.js-toc',
        
        contentSelector: '.js-toc-content',
        
        headingSelector: 'h1, h2, h3',
        
        hasInnerContainers: true,
    });
</script>


  </body>
</html>
